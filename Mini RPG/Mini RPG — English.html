<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini RPG</title>
    <style>
      body {
        background: linear-gradient(135deg, #1a2a3a 0%, #2c3e50 100%);
        color: #ecf0f1;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        text-align: center;
        padding: 10px;
        margin: 0;
        min-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .title {
        font-size: 2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .container {
        background: rgba(52, 73, 94, 0.9);
        padding: clamp(1rem, 3vw, 2rem);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        max-width: 800px;
        width: 95%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 0.5rem;
        margin: 1rem 0;
        padding: clamp(0.8rem, 2vw, 1rem);
        background: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        align-items: center;
      }
      .battle-log {
        height: clamp(150px, 40vh, 400px);
        overflow-y: auto;
        background: rgba(44, 62, 80, 0.7);
        padding: clamp(0.8rem, 2vw, 1rem);
        border-radius: 15px;
        margin: 1rem 0;
        text-align: left;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .battle-log .message {
        margin: 0.3rem 0;
      }
      .battle-log .message:nth-child(-n + 2) {
        font-weight: bold;
        font-size: 1.05em;
        padding: 0.3rem;
        border-left: 2px solid #3498db;
        margin-left: -0.3rem;
        background: rgba(52, 152, 219, 0.05);
      }
      .success {
        color: #2ecc71;
      }
      .battle-log .success:nth-child(-n + 2) {
        border-left: 2px solid #2ecc71;
        background: rgba(46, 204, 113, 0.05);
      }
      .warning {
        color: #f1c40f;
      }
      .battle-log .warning:nth-child(-n + 2) {
        border-left: 2px solid #f1c40f;
        background: rgba(241, 196, 15, 0.05);
      }
      .info {
        color: #87ceeb;
      }
      .battle-log .info:nth-child(-n + 2) {
        border-left: 2px solid #87ceeb;
        background: rgba(135, 206, 235, 0.05);
      }
      .info-success {
        color: #27c6a3;
      }
      .battle-log .info-success:nth-child(-n + 2) {
        border-left: 2px solid #2ecc71;
        background: rgba(46, 204, 113, 0.05);
      }
      .danger {
        color: #e74c3c;
      }
      .battle-log .danger:nth-child(-n + 2) {
        border-left: 2px solid #e74c3c;
        background: rgba(231, 76, 60, 0.05);
      }
      .info-danger {
        color: #e67e22;
      }
      .battle-log .info-danger:nth-child(-n + 2) {
        border-left: 2px solid #e67e22;
        background: rgba(230, 126, 34, 0.05);
      }
      .info-warning {
        color: #f5b041;
      }
      .battle-log .info-warning:nth-child(-n + 2) {
        border-left: 2px solid #f5b041;
        background: rgba(245, 176, 65, 0.05);
      }
      button {
        padding: clamp(0.5rem, 2vw, 0.8rem) clamp(1rem, 4vw, 1.5rem);
        margin: 0.5rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 300px;
        user-select: none;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        background: linear-gradient(145deg, #2980b9, #3498db);
      }
      button.disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        color: #e0e0e0;
        cursor: not-allowed;
        opacity: 0.7;
        box-shadow: none;
        filter: grayscale(0.3);
        pointer-events: none;
      }
      .monster {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 0.5rem;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .level-up {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 1rem 0;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .level-up.visible {
        visibility: visible;
        opacity: 1;
      }
      button:disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .game-status {
        color: #f39c12;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-over {
        color: #e74c3c;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-victory {
        color: #2ecc71;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .info-section {
        margin-top: 2rem;
        padding: 1rem;
        background-color: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .info-content {
        text-align: left;
        padding: 1rem;
      }
      .info-content h3 {
        color: #3498db;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .info-content p {
        margin: 0.5rem 0;
        line-height: 1.4;
      }
      .info-content h2 {
        color: #2ecc71;
        margin-bottom: 1rem;
      }
      .stats .low-hp {
        color: #e74c3c;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
      }

      .stats .ready-to-level {
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
        cursor: pointer;
        color: #2ecc71;
      }
      .stats .ready-to-level-button {
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
        cursor: pointer;
        background: linear-gradient(145deg, #27ae60, #2ecc71);
        border-radius: 8px;
        padding: 0.2rem 0.5rem;
        border: none;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .stats .ready-to-level-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }
      .stats .ready-to-level-button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .hidden {
        display: none !important;
      }

      .auto-explore {
        background: rgba(44, 62, 80, 0.7);
        padding: 1rem;
        border-radius: 15px;
        margin: 1rem 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .auto-explore-checkbox {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
        width: 100%;
        justify-content: center;
      }

      .auto-explore input[type='checkbox'] {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border: 2px solid #3498db;
        border-radius: 5px;
        background: rgba(52, 73, 94, 0.9);
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
      }

      .auto-explore input[type='checkbox']:checked {
        background: #3498db;
      }

      .auto-explore input[type='checkbox']:checked::after {
        content: 'âœ“';
        position: absolute;
        color: white;
        font-size: 14px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .auto-explore input[type='checkbox']:hover {
        border-color: #2980b9;
        box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
      }

      .auto-explore label {
        color: #ecf0f1;
        margin-left: 0.8rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        cursor: pointer;
        user-select: none;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
      }

      .auto-explore-helper-text {
        font-size: 0.9em;
        color: #95a5a6;
        margin-top: 0.2rem;
        text-align: center;
        font-style: italic;
      }

      @media (max-width: 700px) {
        body {
          padding-top: 0px;
          padding-bottom: 0px;
        }
        .title {
          font-size: 1.5rem;
        }
        .container {
          padding: 1rem;
          width: 100%;
          border-radius: 0;
        }
        .stats {
          grid-template-columns: repeat(2, 1fr);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        button {
          width: 100%;
        }
        .battle-log {
          height: clamp(150px, 70vh, 250px);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        .info-section {
          margin-top: 1rem;
          padding: 0.8rem;
        }
        .info-content {
          padding: 0.8rem;
        }
        .info-content h3 {
          margin-top: 1rem;
          margin-bottom: 0.3rem;
        }
        .info-content p {
          margin: 0.3rem 0;
        }
      }

      .actions-grid {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        width: 100%;
        align-items: center;
      }
      .actions-row {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        width: 100%;
        justify-content: center;
      }

      .btn-attack {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        color: #fff;
        font-size: 1.3em;
        min-width: 160px;
        max-width: 350px;
        padding: 1rem 0;
      }
      .btn-attack:hover {
        background: linear-gradient(145deg, #c0392b, #e74c3c);
      }

      @media (max-width: 700px) {
        .actions-grid {
          gap: 0.2rem;
        }
        .btn-attack {
          font-size: 1.25em;
          min-width: 0;
          width: 100%;
          max-width: 100%;
          margin-bottom: 0.2rem;
        }
        .actions-row {
          flex-direction: row;
          gap: 0.2rem;
          width: 100%;
        }
      }

      .btn-escape {
        background: linear-gradient(145deg, #f1c40f, #f39c12);
        color: #fff;
      }
      .btn-escape:hover {
        background: linear-gradient(145deg, #f39c12, #f1c40f);
      }

      .btn-explore {
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: #fff;
      }
      .btn-explore:hover {
        background: linear-gradient(145deg, #2980b9, #3498db);
      }

      .btn-advance {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        color: #fff;
      }
      .btn-advance:hover {
        background: linear-gradient(145deg, #27ae60, #2ecc71);
      }

      .stats .stat-hp {
        grid-column: auto;
      }

      @media (max-width: 700px) {
        .stats .stat-hp {
          grid-column: 1 / -1;
          justify-self: center;
          text-align: center;
        }
      }

      .levelup-stat {
        padding: 0.18em 0.7em;
        font-weight: 500;
        color: #4a4a4a;
        font-size: 1em;
        margin-right: 0.4em;
        transition: border-color 0.2s;
        letter-spacing: 0.5px;
      }

      .levelup-stat:last-child {
        margin-right: 0;
      }

      @media (max-width: 700px) {
        .levelup-stat {
          font-size: 0.98em;
          padding: 0.18em 0.4em;
          margin-right: 0.2em;
        }
      }

      .difficulty-selection {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 2rem;
        text-align: center;
      }

      .difficulty-selection h3 {
        color: #3498db;
        margin-bottom: 1rem;
        font-size: 1.2em;
      }

      .difficulty-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.8rem;
      }

      .btn-difficulty {
        padding: 1rem;
        font-size: 1rem;
        font-weight: bold;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .btn-difficulty:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .btn-blessed {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        color: white;
      }

      .btn-normal {
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
      }

      .btn-heroic {
        background: linear-gradient(145deg, #f39c12, #e67e22);
        color: white;
      }

      .btn-legendary {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        color: white;
      }

      @media (max-width: 700px) {
        .difficulty-buttons {
          grid-template-columns: 1fr;
        }

        .difficulty-selection {
          padding: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <script type="module">
      //prettier-ignore
      const { Fragment, setSignal, h, setEffect } = (() => {let currentObserver=null;function setSignal(value){const subscribers=new Set();const read=()=>{if(currentObserver)subscribers.add(currentObserver);return value;};const write=newValue=>{value=typeof newValue==='function'?newValue(value):newValue;subscribers.forEach(fn=>fn());};return[read,write];}function setEffect(fn){const execute=()=>{currentObserver=execute;fn();currentObserver=null;};execute();}function setMemo(fn){const[get,set]=setSignal();setEffect(()=>set(fn()));return get;}const SVG_NS='http://www.w3.org/2000/svg';const isSvg=tag=>/^(svg|path|circle|rect|line|polygon|polyline|ellipse|g|text|defs|use)$/.test(tag);function Fragment(props){const fragment=document.createDocumentFragment();insertChildren(fragment,props.children);return fragment;}function insertChildren(parent,children){if(!children)return;const childArray=Array.isArray(children)?children.flat():[children];for(const child of childArray){if(child==null||typeof child==='boolean')continue;if(typeof child==='function'){const marker=document.createComment('');let lastValue=null;parent.appendChild(marker);setEffect(()=>{const value=child();if(value===lastValue)return;lastValue=value;let node;while((node=marker.nextSibling)&&node.nodeType!==8)node.remove();if(value==null)return;if(typeof value==='object'&&value.nodeType){parent.insertBefore(value,marker.nextSibling);}else if(typeof value!=='object'){parent.insertBefore(document.createTextNode(String(value)),marker.nextSibling);}});}else if(typeof child==='object'&&child.nodeType){parent.appendChild(child);}else{parent.appendChild(document.createTextNode(String(child)));}}}function jsx(type,props={}){if(typeof type==='function')return type(props);if(type===Fragment)return Fragment(props);const el=isSvg(type)?document.createElementNS(SVG_NS,type):document.createElement(type);for(const key in props){if(key==='children'||key==='ref')continue;if(key.startsWith('on')&&typeof props[key]==='function'){el.addEventListener(key.slice(2).toLowerCase(),props[key]);}else if(key==='style'&&typeof props[key]==='object'){if(typeof props[key]==='function'){setEffect(()=>{Object.assign(el.style,props[key]());});}else{Object.assign(el.style,props[key]);}}else if(key==='className'||key==='class'){if(typeof props[key]==='function'){setEffect(()=>{el.setAttribute('class',props[key]());});}else{el.setAttribute('class',props[key]);}}else if(typeof props[key]!=='function'){el.setAttribute(key,props[key]);}}if(props.ref&&typeof props.ref==='function'){props.ref(el);}insertChildren(el,props.children);return el;}function h(type,props,...children){props=props||{};if(children.length)props.children=children.length===1?children[0]:children;return jsx(type,props);}return{setSignal,setEffect,setMemo,jsx,h,Fragment};})();

      //prettier-ignore
      const allDungeons = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV'];
      const monsterTypes = [
        { name: 'Goblin ðŸ‘½', baseHp: 20, baseAtk: 5, baseDef: 5, baseDex: 5, sinceLevel: 1, untilLevel: 3 },
        { name: 'Troll ðŸ¦', baseHp: 50, baseAtk: 10, baseDef: 2, baseDex: 5, sinceLevel: 3, untilLevel: 6 },
        { name: 'Orc ðŸ’ª', baseHp: 30, baseAtk: 10, baseDef: 8, baseDex: 10, sinceLevel: 4, untilLevel: 8 },
        { name: 'Zombie ðŸ§Ÿâ€â™‚ï¸', baseHp: 20, baseAtk: 12, baseDef: 12, baseDex: 2, sinceLevel: 5, untilLevel: 10 },
        { name: 'Demon ðŸ˜ˆ', baseHp: 50, baseAtk: 15, baseDef: 5, baseDex: 15, sinceLevel: 7 },
        { name: 'Horror â–“', baseHp: 20, baseAtk: 17, baseDef: 10, baseDex: 33, sinceLevel: 9 },
        { name: 'Lich ðŸ’€', baseHp: 50, baseAtk: 20, baseDef: 15, baseDex: 20, sinceLevel: 11 },
        { name: 'Dragon ðŸ‰', baseHp: 120, baseAtk: 20, baseDef: 20, baseDex: 5, sinceLevel: 13 },
      ];
      const difficultiesConfigs = {
        blessed: {
          name: 'Blessed',
          statsUpgrades: {
            atk: [5, 7, 9, 12, 15],
            def: [5, 7, 9, 12, 15],
            dex: 5,
            cres: 15,
            hp: [50, 85, 125, 200],
          },
          className: 'success',
        },
        normal: {
          name: 'Normal',
          statsUpgrades: {
            atk: [4, 5, 7, 9, 11],
            def: [4, 5, 7, 9, 11],
            dex: 4,
            cres: 10,
            hp: [40, 70, 100, 150],
          },
          className: 'info',
        },
        heroic: {
          name: 'Heroic',
          statsUpgrades: {
            atk: [4, 5, 6, 7, 9],
            def: [4, 5, 6, 7, 9],
            dex: 3,
            cres: 7,
            hp: [30, 50, 70, 100],
          },
          className: 'warning',
        },
        legendary: {
          name: 'Legendary',
          statsUpgrades: {
            atk: [3, 4, 5, 6, 7],
            def: [3, 4, 5, 6, 7],
            dex: 2,
            cres: 5,
            hp: [25, 35, 50, 75],
          },
          className: 'danger',
        },
      };
      const constants = {
        wonBattleExpBonus: 0.25,
      };
      const defaultHero = {
        level: 1,
        hp: 100,
        maxHp: 100,
        atk: 10,
        def: 5,
        dex: 5,
        cres: 0,
        exp: 0,
        expToNext: 10,
        battlesLeft: 150,
      };
      const defaultBattleLog = [{ message: 'New game', className: 'info' }];
      const defaultData = {
        hero: defaultHero,
        difficulty: null,
        currentDungeonIndex: 0,
        currentMonsters: [],
        battleLog: defaultBattleLog,
        showLevelUp: false,
        didEscape: false,
        canAdvance: false,
        isAutoExploreActive: false,
        lastBattleExp: 0,
      };
      const data = (() => {
        try {
          const savedData = localStorage.getItem('miniRpgSave');
          if (!savedData) return defaultData;

          const data = JSON.parse(savedData);
          return {
            hero: data.hero || defaultHero,
            difficulty: data.difficulty || null,
            currentDungeonIndex: data.currentDungeonIndex || 0,
            currentMonsters: data.currentMonsters || [],
            battleLog: [...data.battleLog, { message: 'Resuming saved game', className: 'info' }] || defaultBattleLog,
            showLevelUp: data.showLevelUp || false,
            didEscape: data.didEscape || false,
            lastBattleExp: data.lastBattleExp || 0,
            canAdvance: data.canAdvance || false,
            isAutoExploreActive: false,
          };
        } catch (error) {
          console.error('Error loading saved data:', error);
          return defaultData;
        }
      })();

      console.log(data);

      function Game() {
        const [hero, setHero] = setSignal(data.hero);
        const [difficulty, setDifficulty] = setSignal(data.difficulty);
        const [currentDungeonIndex, setCurrentDungeonIndex] = setSignal(data.currentDungeonIndex);
        const [currentMonsters, setCurrentMonsters] = setSignal(data.currentMonsters);
        const [battleLog, setBattleLog] = setSignal(data.battleLog);
        const [showLevelUp, setShowLevelUp] = setSignal(data.showLevelUp);
        const [didEscape, setDidEscape] = setSignal(data.didEscape);
        const [canAdvance, setCanAdvance] = setSignal(data.canAdvance);
        const [lastBattleExp, setLastBattleExp] = setSignal(data.lastBattleExp);
        const [isAutoExploreActive, setIsAutoExploreActive] = setSignal(data.isAutoExploreActive);
        const [restartFirstClick, setRestartFirstClick] = setSignal(false);

        setEffect(() => {
          const saveData = {
            hero: hero(),
            difficulty: difficulty(),
            currentDungeonIndex: currentDungeonIndex(),
            currentMonsters: currentMonsters(),
            battleLog: battleLog(),
            showLevelUp: showLevelUp(),
            didEscape: didEscape(),
            canAdvance: canAdvance(),
            lastBattleExp: lastBattleExp(),
          };

          try {
            localStorage.setItem('miniRpgSave', JSON.stringify(saveData));
          } catch (error) {
            console.error('Error saving data:', error);
          }
        });

        const isInBattle = () => currentMonsters().length > 0;
        const isEnoughExp = () => hero().exp >= hero().expToNext;

        const generateMonsters = () => {
          let numMonsters;
          if (currentDungeonIndex() >= 11) {
            numMonsters = Math.floor(Math.random() * 5) + 4; // 4-8
          } else if (currentDungeonIndex() >= 7) {
            numMonsters = Math.floor(Math.random() * 5) + 3; // 3-7
          } else if (currentDungeonIndex() >= 3) {
            numMonsters = Math.floor(Math.random() * 5) + 2; // 2-6
          } else {
            numMonsters = Math.floor(Math.random() * 5) + 1; // 1-5
          }
          const monsters = [];
          const currentLevel = currentDungeonIndex() + 1;

          const calculateStat = (baseStat, incrementalFactor) => Math.round(baseStat * (1 + currentDungeonIndex() * incrementalFactor));

          for (let i = 0; i < numMonsters; i++) {
            const availableMonsters = monsterTypes.filter(
              type => type.sinceLevel <= currentLevel && (type.untilLevel || 20) >= currentLevel
            );
            const type = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];

            monsters.push({
              ...type,
              hp: calculateStat(type.baseHp, 0.3),
              maxHp: calculateStat(type.baseHp, 0.3),
              atk: calculateStat(type.baseAtk, 0.4),
              def: calculateStat(type.baseDef, 0.4),
              dex: type.baseDex,
            });
          }

          return monsters;
        };

        const checkAndHandleHeroDeath = () => {
          if (hero().hp > 0) return;
          setHero({ ...hero(), isDead: true });
          addToLog({
            message: 'Hero defeated! Game over.',
            className: 'danger',
          });
        };

        const healHero = () => {
          setHero({ ...hero(), hp: hero().maxHp });
          addToLog({
            message: 'Hero fully healed!',
            className: 'success',
          });
        };

        const startBattle = () => {
          if (isInBattle() || isEndGame()) return;

          if (hero().battlesLeft <= 0) {
            addToLog({
              message: "You've run out of battles! Game over.",
              className: 'danger',
            });
            setHero({
              ...hero(),
              isDead: true,
            });
            checkAndHandleHeroDeath();
            return;
          }

          const newMonsters = generateMonsters();
          setCurrentMonsters(newMonsters);
          setDidEscape(false);

          const monsterNames = newMonsters
            .map(m => m.name)
            .join(', ')
            .replace(/, ([^,]+)$/, ' and $1');
          addToLog({
            message: `âš”ï¸ You encounter ${newMonsters.length} ${newMonsters.length === 1 ? 'monster' : 'monsters'}: ${monsterNames}`,
            className: 'warning',
          });
        };

        const handleAutoExplore = e => {
          setIsAutoExploreActive(e.target.checked);
          if (e.target.checked) if (!isInBattle()) startBattle();
        };

        const scrollToLevelUp = () => {
          if (!showLevelUp()) return;
          setTimeout(() => {
            const levelUpBox = document.getElementById('level-up');
            if (levelUpBox) levelUpBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        };

        const isEndGame = () => hero().isDead || hero().isVictory;
        const isGameStart = () => !difficulty();

        const addToLog = ({ message, className, dontRepeat = false }) => {
          if (dontRepeat && battleLog()[battleLog().length - 1]?.message === message) return;

          const logEntry = { message, className: className || 'info' };
          let newLog = [...battleLog(), logEntry];
          if (newLog.length > 100) newLog = newLog.slice(-100);
          setBattleLog(newLog);
        };

        const calculateExp = monster => {
          const baseExp = monster.maxHp * monster.atk * monster.def * Math.max(1, monster.dex / 10);
          let exp = baseExp / 100;

          console.log('calculateExp', { monster, baseExp, exp });

          return Math.round(exp);
        };

        const calculateDamage = (atk, targetDef, dex, cres) => {
          const critChance = dex * ((100 - cres) / 100);
          const isCritical = Math.random() * 100 < critChance;

          const baseDamage = Math.max(1, atk - targetDef);

          const rolledDamage = isCritical ? baseDamage : baseDamage * (0.6 + Math.random() * 0.8); //Critical damage always average

          const finalDamage = isCritical ? rolledDamage * 3 : rolledDamage;

          return { damage: Math.round(finalDamage), isCritical };
        };

        const attack = () => {
          if (hero().isDead || !isInBattle()) return;

          const monster = currentMonsters()[0];
          const { damage, isCritical } = calculateDamage(hero().atk, monster.def, hero().dex, 0);
          monster.hp = Math.max(0, monster.hp - damage);
          addToLog({
            message: `Hero â†’ ${monster.name} ${isCritical ? '| CRITICAL!' : ''} | ${damage} DAMAGE (${monster.hp}/${monster.maxHp} HP)`,
            className: isCritical ? 'info-success' : 'info',
          });

          if (monster.hp <= 0) {
            const expGained = calculateExp(monster);
            setLastBattleExp(lastBattleExp() + expGained);
            setHero({
              ...hero(),
              exp: hero().exp + expGained,
            });
            addToLog({
              message: `${monster.name} defeated +${expGained} EXP ${
                currentMonsters().length > 1
                  ? `| ${currentMonsters().length - 1} monster${currentMonsters().length - 1 === 1 ? '' : 's'} remaining`
                  : ''
              }`,
              className: 'info-success',
            });

            setCurrentMonsters(currentMonsters().filter(m => m !== monster));

            if (currentMonsters().length === 0) endBattle();

            return;
          }

          const monsterAttack = calculateDamage(monster.atk, hero().def, monster.dex, hero().cres);
          setHero({
            ...hero(),
            hp: Math.max(0, hero().hp - monsterAttack.damage),
          });

          const damagePercentage = (monsterAttack.damage / hero().maxHp) * 100;
          let damageClass = 'info-warning';
          if (damagePercentage > 10) damageClass = 'danger';
          else if (damagePercentage > 3) damageClass = 'info-danger';

          addToLog({
            message: `${monster.name} â†’ Hero ${monsterAttack.isCritical ? '| CRITICAL!' : ''} | ${monsterAttack.damage} DAMAGE`,
            className: damageClass,
          });

          checkAndHandleHeroDeath();
        };

        const escape = () => {
          if (hero().isDead || !isInBattle()) return;

          addToLog({
            message: `You escaped!${isAutoExploreActive() ? ' (Auto-explore disabled)' : ''}`,
            className: 'success',
          });
          setCurrentMonsters([]);
          setDidEscape(true);
          setHero({
            ...hero(),
            escapesLeft: hero().escapesLeft - 1,
          });
          healHero();
          if (isAutoExploreActive()) document.getElementById('auto-explore').click();
          endBattle();
        };

        const endBattle = () => {
          if (!didEscape()) {
            const extraExp = Math.round(lastBattleExp() * constants.wonBattleExpBonus);
            addToLog({
              message: `Victory! +${extraExp} bonus EXP!`,
              className: 'success',
            });
            setHero({
              ...hero(),
              exp: hero().exp + extraExp,
            });
            setLastBattleExp(0);

            if (!canAdvance()) setCanAdvance(true);

            if (isAutoExploreActive() && !isEndGame()) {
              addToLog({
                message: 'Auto exploring...',
                className: 'info-warning',
              });
              setTimeout(startBattle, 1000);
            }
          }

          if (isEnoughExp()) setShowLevelUp(true);

          setHero({
            ...hero(),
            battlesLeft: hero().battlesLeft - 1,
          });
        };

        const advanceDungeon = () => {
          if (isInBattle() || isEndGame() || isAutoExploreActive() || !canAdvance()) {
            addToLog({
              message: 'You cannot advance, you are in battle!',
              className: 'info-warning',
              dontRepeat: true,
            });
            return;
          }

          if (!canAdvance()) {
            addToLog({
              message: `You cannot advance to the next dungeon yet! You must win at least 1 battle`,
              className: 'info-warning',
              dontRepeat: true,
            });
            return;
          } else if (currentDungeonIndex() === allDungeons.length - 2) {
            addToLog({
              message: `You have cleared all dungeons! You won the game, congratulations!`,
              className: 'success',
              dontRepeat: true,
            });
            setHero({
              ...hero(),
              isVictory: true,
            });
          } else {
            healHero();
            setCurrentDungeonIndex(currentDungeonIndex() + 1);
            setCanAdvance(false);
            addToLog({
              message: `Advanced to Dungeon ${allDungeons[currentDungeonIndex()]}!`,
              className: 'success',
              dontRepeat: true,
            });
          }
        };

        const getStatIncrease = (stat, currentValue) => {
          const currentDifficulty = difficultiesConfigs[difficulty()];
          const statsUpgrades = currentDifficulty.statsUpgrades;

          switch (stat) {
            case 'atk':
              const atkUpgrades = statsUpgrades.atk;
              if (currentValue >= 150) return atkUpgrades[4];
              if (currentValue >= 100) return atkUpgrades[3];
              if (currentValue >= 60) return atkUpgrades[2];
              if (currentValue >= 30) return atkUpgrades[1];
              return atkUpgrades[0];
            case 'def':
              const defUpgrades = statsUpgrades.def;
              if (currentValue >= 130) return defUpgrades[4];
              if (currentValue >= 85) return defUpgrades[3];
              if (currentValue >= 50) return defUpgrades[2];
              if (currentValue >= 20) return defUpgrades[1];
              return defUpgrades[0];
            case 'hp':
              const hpUpgrades = statsUpgrades.hp;
              if (currentValue >= 800) return hpUpgrades[3];
              if (currentValue >= 400) return hpUpgrades[2];
              if (currentValue >= 200) return hpUpgrades[1];
              return hpUpgrades[0];
            case 'dex':
              return statsUpgrades.dex;
            case 'cres':
              return statsUpgrades.cres;
            default:
              return 0;
          }
        };

        const levelUp = stat => {
          const currentHero = hero();
          const newHero = {
            ...currentHero,
            level: currentHero.level + 1,
            exp: currentHero.exp - currentHero.expToNext,
            expToNext: Math.floor(currentHero.expToNext * 1.12 + currentHero.level * 10),
            escapesLeft: currentHero.escapesLeft + 1,
          };

          if (stat === 'hp') {
            const increase = getStatIncrease(stat, currentHero.maxHp);
            newHero.maxHp += increase;
            newHero.hp = newHero.maxHp;
          } else {
            const increase = getStatIncrease(stat, currentHero[stat]);
            newHero[stat] += increase;
          }

          setHero(newHero);
          setShowLevelUp(false);
          healHero();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        const resetGame = () => {
          setHero(defaultData.hero);
          setDifficulty(defaultData.difficulty);
          setCurrentDungeonIndex(defaultData.currentDungeonIndex);
          setCurrentMonsters(defaultData.currentMonsters);
          setBattleLog(defaultData.battleLog);
          setShowLevelUp(defaultData.showLevelUp);
          setDidEscape(defaultData.didEscape);
          setCanAdvance(defaultData.canAdvance);
          setLastBattleExp(defaultData.lastBattleExp);
          if (isAutoExploreActive()) {
            setIsAutoExploreActive(false);
            document.getElementById('auto-explore').click();
          }
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        const handleRestart = () => {
          if (restartFirstClick()) {
            resetGame();
            setRestartFirstClick(false);
            return;
          }
          setRestartFirstClick(true);
          setTimeout(() => setRestartFirstClick(false), 2000);
        };

        const selectDifficulty = selectedDifficulty => {
          setDifficulty(selectedDifficulty);

          addToLog({
            message: `Difficulty selected: ${difficultiesConfigs[selectedDifficulty].name}`,
            className: difficultiesConfigs[selectedDifficulty].className,
          });
          addToLog({
            message: 'Explore to start',
            className: 'info',
          });
        };

        return h(
          Fragment,
          null,
          h(
            'div',
            { className: 'container' },
            h(
              'h1',
              { className: () => (difficulty() ? `title ${difficultiesConfigs[difficulty()].className}` : 'title') },
              () => `Mini RPG${difficulty() ? ` - ${difficultiesConfigs[difficulty()].name}` : ''}`
            ),
            h('h2', { className: () => (hero().isDead ? 'game-over' : hero().isVictory ? 'game-victory' : 'game-status') }, () =>
              hero().isVictory
                ? 'You won the game, congratulations!'
                : `Dungeon ${allDungeons[currentDungeonIndex()]} | Battles: ${hero().battlesLeft}`
            ),
            h('div', { className: 'stats' }, [
              h('div', null, () => `Level: ${hero().level}`),
              h(
                'div',
                {
                  className: () => (isEnoughExp() ? (showLevelUp() ? 'ready-to-level-button' : 'ready-to-level') : ''),
                  onclick: scrollToLevelUp,
                },
                () => (isEnoughExp() && showLevelUp() ? 'Level Up!' : `EXP: ${hero().exp}/${hero().expToNext}`)
              ),
              h('div', null, () => `ATK: ${hero().atk}`),
              h('div', null, () => `DEF: ${hero().def}`),
              h('div', null, () => `CRIT: ${hero().dex}%`),
              h('div', null, () => `CRES: ${hero().cres}%`),
              h(
                'div',
                { className: () => `stat-hp ${hero().hp / hero().maxHp <= 0.35 ? 'low-hp' : ''}`, style: 'text-align: center;' },
                () => `HP: ${hero().hp}/${hero().maxHp}`
              ),
            ]),
            h('div', { className: () => (isGameStart() ? 'battle-log' : 'battle-log hidden') }, [
              h('div', { className: 'difficulty-selection' }, [
                h('h3', { style: 'color: white; text-decoration: underline;' }, 'Select Difficulty'),
                h('div', { className: 'difficulty-buttons' }, [
                  h('button', { className: 'btn-difficulty btn-blessed', onclick: () => selectDifficulty('blessed') }, 'Blessed'),
                  h('button', { className: 'btn-difficulty btn-normal', onclick: () => selectDifficulty('normal') }, 'Normal'),
                  h('button', { className: 'btn-difficulty btn-heroic', onclick: () => selectDifficulty('heroic') }, 'Heroic'),
                  h('button', { className: 'btn-difficulty btn-legendary', onclick: () => selectDifficulty('legendary') }, 'Legendary'),
                ]),
              ]),
            ]),
            h(
              'div',
              { className: () => (!isGameStart() ? 'battle-log' : 'battle-log hidden') },
              Array.from({ length: 100 }, (_, i) =>
                h(
                  'div',
                  { key: i, className: () => `message ${battleLog()[battleLog().length - i - 1]?.className}` },
                  () => battleLog()[battleLog().length - i - 1]?.message
                )
              )
            ),
            h('div', { className: 'actions-grid' }, [
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  {
                    className: () => (isEndGame() || !isInBattle() || isGameStart() ? 'disabled btn-attack' : 'btn-attack'),
                    onclick: attack,
                  },
                  'Attack'
                ),
              ]),
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  {
                    className: () => (isEndGame() || !isInBattle() || isGameStart() ? 'disabled btn-escape' : 'btn-escape'),
                    onclick: escape,
                  },
                  () => `Escape`
                ),
                h(
                  'button',
                  {
                    className: () =>
                      isInBattle() || isEndGame() || isAutoExploreActive() || isGameStart() ? 'disabled btn-explore' : 'btn-explore',
                    onclick: startBattle,
                  },
                  'Explore'
                ),
              ]),
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  {
                    className: () =>
                      isInBattle() || isEndGame() || isAutoExploreActive() || !canAdvance() || isGameStart()
                        ? 'disabled btn-advance'
                        : 'btn-advance',
                    onclick: advanceDungeon,
                  },
                  'Advance Dungeon'
                ),
              ]),
              h('button', { className: () => (isEndGame() ? 'btn-reset' : 'hidden'), onclick: resetGame }, 'Start Over'),
            ]),
            h('div', { className: () => (isGameStart() ? 'auto-explore hidden' : 'auto-explore') }, [
              h('div', { className: 'auto-explore-checkbox' }, [
                h('input', {
                  type: 'checkbox',
                  value: false,
                  id: 'auto-explore',
                  onchange: handleAutoExplore,
                  disabled: () => isGameStart(),
                }),
                h('label', { for: 'auto-explore' }, 'Auto-Explore'),
              ]),
              h('p', { className: 'auto-explore-helper-text' }, 'Automatically explore after each victory. Disables when escaping.'),
            ]),
            h('div', { id: 'level-up', className: () => (!isEndGame() && showLevelUp() ? 'level-up visible' : 'level-up') }, [
              h('h2', null, 'Level Up!'),
              h(
                'div',
                { style: 'display: flex; justify-content: center; gap: 1rem; margin: 1rem 0; font-size: 0.9em; font-style: italic;' },
                [
                  h('div', { className: 'levelup-stat' }, () => `ATK: ${hero().atk}`),
                  h('div', { className: 'levelup-stat' }, () => `DEF: ${hero().def}`),
                  h('div', { className: 'levelup-stat' }, () => `CRIT: ${hero().dex}%`),
                  h('div', { className: 'levelup-stat' }, () => `CRES: ${hero().cres}%`),
                  h('div', { className: 'levelup-stat' }, () => `HP: ${hero().maxHp}`),
                ]
              ),
              h('button', { onclick: () => levelUp('atk') }, 'Increase ATK'),
              h('button', { onclick: () => levelUp('def') }, 'Increase DEF'),
              h('button', { onclick: () => levelUp('dex') }, 'Increase CRIT'),
              h('button', { onclick: () => levelUp('cres') }, 'Increase CRES'),
              h('button', { onclick: () => levelUp('hp') }, 'Increase HP'),
            ]),
            h('button', { className: 'btn-escape', onclick: handleRestart }, () =>
              restartFirstClick() ? 'PRESS AGAIN TO CONFIRM' : 'RESET AND START OVER'
            )
          ),
          h('div', { className: 'container info-section' }, [
            h('h2', null, 'Information'),
            h('div', { className: 'info-content' }, [
              h('h3', null, 'Objective'),
              h(
                'p',
                null,
                `Clear all ${allDungeons.length} dungeons before running out of your ${defaultHero.battlesLeft} available battles.`
              ),
              h('h3', null, 'How to play?'),
              h('p', null, '1. Find enemies using the "Explore" button.'),
              h('p', null, '2. Each battle has multiple monsters. Kill them all to win the battle.'),
              h('p', null, '3. Gain EXP and level up to improve your stats.'),
              h('p', null, '4. Win one battle in each dungeon to advance to the next.'),
              h('p', null, '- The game saves automatically all the time. You can exit and return later.'),
              h('h3', null, 'Important mechanics'),
              h('p', null, '- Escaping ends the battle and heals the hero.'),
              h('p', null, '- The hero also heals when advancing dungeons.'),
              h('p', null, '- The hero levels up at the end of the current battle, whether escaping or winning.'),
              h('p', null, '- Using level-up (choosing a stat) heals the hero. You can use it anytime, even mid-battle.'),
              h(
                'p',
                null,
                `- Winning a battle gives you a +${constants.wonBattleExpBonus * 100}% EXP bonus from all EXP gained in that battle.`
              ),
              h('h3', null, 'Stats'),
              h('p', null, '- ATK: Increases the damage you deal.'),
              h('p', null, '- DEF: Decreases the damage you take.'),
              h('p', null, '- CRIT: Increases critical hit chance.'),
              h('p', null, '- CRES: Decreases enemy CRIT.'),
              h('p', null, '- HP: Your life; if it reaches zero, game over.'),
              h('p', null, 'As HP, ATK and DEF increase, each level-up gives more of that stat. CRIT and CRES increase by a fixed amount.'),
            ]),
          ])
        );
      }

      const root = document.body;
      root.appendChild(Game());
    </script>
  </body>
</html>
