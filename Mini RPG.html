<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini RPG</title>
    <style>
      body {
        background: linear-gradient(135deg, #1a2a3a 0%, #2c3e50 100%);
        color: #ecf0f1;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        text-align: center;
        padding: 10px;
        margin: 0;
        min-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .title {
        font-size: 2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .container {
        background: rgba(52, 73, 94, 0.9);
        padding: clamp(1rem, 3vw, 2rem);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        max-width: 800px;
        width: 95%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 0.5rem;
        margin: 1rem 0;
        padding: clamp(0.8rem, 2vw, 1rem);
        background: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        align-items: center;
      }
      .battle-log {
        height: clamp(150px, 40vh, 400px);
        overflow-y: auto;
        background: rgba(44, 62, 80, 0.7);
        padding: clamp(0.8rem, 2vw, 1rem);
        border-radius: 15px;
        margin: 1rem 0;
        text-align: left;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .battle-log .message {
        margin: 0.3rem 0;
      }
      .battle-log .message:nth-child(-n + 2) {
        font-weight: bold;
        font-size: 1.05em;
        padding: 0.3rem;
        border-left: 2px solid #3498db;
        margin-left: -0.3rem;
        background: rgba(52, 152, 219, 0.05);
      }
      .battle-log .success {
        color: #2ecc71;
      }
      .battle-log .success:nth-child(-n + 2) {
        border-left: 2px solid #2ecc71;
        background: rgba(46, 204, 113, 0.05);
      }
      .battle-log .error {
        color: #e74c3c;
      }
      .battle-log .error:nth-child(-n + 2) {
        border-left: 2px solid #e74c3c;
        background: rgba(231, 76, 60, 0.05);
      }
      .battle-log .warning {
        color: #f1c40f;
      }
      .battle-log .warning:nth-child(-n + 2) {
        border-left: 2px solid #f1c40f;
        background: rgba(241, 196, 15, 0.05);
      }
      .battle-log .info {
        color: #87ceeb;
      }
      .battle-log .info:nth-child(-n + 2) {
        border-left: 2px solid #87ceeb;
        background: rgba(135, 206, 235, 0.05);
      }
      .battle-log .info-success {
        color: #27c6a3;
      }
      .battle-log .info-success:nth-child(-n + 2) {
        border-left: 2px solid #2ecc71;
        background: rgba(46, 204, 113, 0.05);
      }
      .battle-log .danger {
        color: #e74c3c;
      }
      .battle-log .danger:nth-child(-n + 2) {
        border-left: 2px solid #e74c3c;
        background: rgba(231, 76, 60, 0.05);
      }
      .battle-log .info-danger {
        color: #e67e22;
      }
      .battle-log .info-danger:nth-child(-n + 2) {
        border-left: 2px solid #e67e22;
        background: rgba(230, 126, 34, 0.05);
      }
      .battle-log .info-warning {
        color: #f5b041;
      }
      .battle-log .info-warning:nth-child(-n + 2) {
        border-left: 2px solid #f5b041;
        background: rgba(245, 176, 65, 0.05);
      }
      button {
        padding: clamp(0.5rem, 2vw, 0.8rem) clamp(1rem, 4vw, 1.5rem);
        margin: 0.5rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 300px;
        user-select: none;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        background: linear-gradient(145deg, #2980b9, #3498db);
      }
      button.disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        color: #e0e0e0;
        cursor: not-allowed;
        opacity: 0.7;
        box-shadow: none;
        filter: grayscale(0.3);
        pointer-events: none;
      }
      .monster {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 0.5rem;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .level-up {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 1rem 0;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .level-up.visible {
        visibility: visible;
        opacity: 1;
      }
      button:disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .game-status {
        color: #f39c12;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-over {
        color: #e74c3c;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-victory {
        color: #2ecc71;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .info-section {
        margin-top: 2rem;
        padding: 1rem;
        background-color: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .info-content {
        text-align: left;
        padding: 1rem;
      }
      .info-content h3 {
        color: #3498db;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .info-content p {
        margin: 0.5rem 0;
        line-height: 1.4;
      }
      .info-content h2 {
        color: #2ecc71;
        margin-bottom: 1rem;
      }
      .stats .low-hp {
        color: #e74c3c;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
      }

      .stats .ready-to-level {
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
        cursor: pointer;
        color: #2ecc71;
      }
      .stats .ready-to-level-button {
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
        cursor: pointer;
        background: linear-gradient(145deg, #27ae60, #2ecc71);
        border-radius: 8px;
        padding: 0.2rem 0.5rem;
        border: none;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .stats .ready-to-level-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }
      .stats .ready-to-level-button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .hidden {
        display: none;
      }

      .auto-explore {
        background: rgba(44, 62, 80, 0.7);
        padding: 1rem;
        border-radius: 15px;
        margin: 1rem 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .auto-explore-checkbox {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
        width: 100%;
        justify-content: center;
      }

      .auto-explore input[type='checkbox'] {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border: 2px solid #3498db;
        border-radius: 5px;
        background: rgba(52, 73, 94, 0.9);
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
      }

      .auto-explore input[type='checkbox']:checked {
        background: #3498db;
      }

      .auto-explore input[type='checkbox']:checked::after {
        content: '✓';
        position: absolute;
        color: white;
        font-size: 14px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .auto-explore input[type='checkbox']:hover {
        border-color: #2980b9;
        box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
      }

      .auto-explore label {
        color: #ecf0f1;
        margin-left: 0.8rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        cursor: pointer;
        user-select: none;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
      }

      .auto-explore-helper-text {
        font-size: 0.9em;
        color: #95a5a6;
        margin-top: 0.2rem;
        text-align: center;
        font-style: italic;
      }

      @media (max-width: 700px) {
        body {
          padding-top: 0px;
          padding-bottom: 0px;
        }
        .title {
          font-size: 1.5rem;
        }
        .container {
          padding: 1rem;
          width: 100%;
          border-radius: 0;
        }
        .stats {
          grid-template-columns: repeat(2, 1fr);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        button {
          width: 100%;
        }
        .battle-log {
          height: clamp(150px, 70vh, 250px);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        .info-section {
          margin-top: 1rem;
          padding: 0.8rem;
        }
        .info-content {
          padding: 0.8rem;
        }
        .info-content h3 {
          margin-top: 1rem;
          margin-bottom: 0.3rem;
        }
        .info-content p {
          margin: 0.3rem 0;
        }
      }

      .actions-grid {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        width: 100%;
        align-items: center;
      }
      .actions-row {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        width: 100%;
        justify-content: center;
      }

      .btn-attack {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        color: #fff;
        font-size: 1.3em;
        min-width: 160px;
        max-width: 350px;
        padding: 1rem 0;
      }
      .btn-attack:hover {
        background: linear-gradient(145deg, #c0392b, #e74c3c);
      }

      @media (max-width: 700px) {
        .actions-grid {
          gap: 0.2rem;
        }
        .btn-attack {
          font-size: 1.25em;
          min-width: 0;
          width: 100%;
          max-width: 100%;
          margin-bottom: 0.2rem;
        }
        .actions-row {
          flex-direction: row;
          gap: 0.2rem;
          width: 100%;
        }
      }

      .btn-escape {
        background: linear-gradient(145deg, #f1c40f, #f39c12);
        color: #fff;
      }
      .btn-escape:hover {
        background: linear-gradient(145deg, #f39c12, #f1c40f);
      }

      .btn-explore {
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: #fff;
      }
      .btn-explore:hover {
        background: linear-gradient(145deg, #2980b9, #3498db);
      }

      .btn-advance {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        color: #fff;
      }
      .btn-advance:hover {
        background: linear-gradient(145deg, #27ae60, #2ecc71);
      }
    </style>
  </head>
  <body>
    <script type="module">
      //prettier-ignore
      const { Fragment, setSignal, h } = (() => {let currentObserver=null;function setSignal(value){const subscribers=new Set();const read=()=>{if(currentObserver)subscribers.add(currentObserver);return value;};const write=newValue=>{value=typeof newValue==='function'?newValue(value):newValue;subscribers.forEach(fn=>fn());};return[read,write];}function setEffect(fn){const execute=()=>{currentObserver=execute;fn();currentObserver=null;};execute();}function setMemo(fn){const[get,set]=setSignal();setEffect(()=>set(fn()));return get;}const SVG_NS='http://www.w3.org/2000/svg';const isSvg=tag=>/^(svg|path|circle|rect|line|polygon|polyline|ellipse|g|text|defs|use)$/.test(tag);function Fragment(props){const fragment=document.createDocumentFragment();insertChildren(fragment,props.children);return fragment;}function insertChildren(parent,children){if(!children)return;const childArray=Array.isArray(children)?children.flat():[children];for(const child of childArray){if(child==null||typeof child==='boolean')continue;if(typeof child==='function'){const marker=document.createComment('');let lastValue=null;parent.appendChild(marker);setEffect(()=>{const value=child();if(value===lastValue)return;lastValue=value;let node;while((node=marker.nextSibling)&&node.nodeType!==8)node.remove();if(value==null)return;if(typeof value==='object'&&value.nodeType){parent.insertBefore(value,marker.nextSibling);}else if(typeof value!=='object'){parent.insertBefore(document.createTextNode(String(value)),marker.nextSibling);}});}else if(typeof child==='object'&&child.nodeType){parent.appendChild(child);}else{parent.appendChild(document.createTextNode(String(child)));}}}function jsx(type,props={}){if(typeof type==='function')return type(props);if(type===Fragment)return Fragment(props);const el=isSvg(type)?document.createElementNS(SVG_NS,type):document.createElement(type);for(const key in props){if(key==='children'||key==='ref')continue;if(key.startsWith('on')&&typeof props[key]==='function'){el.addEventListener(key.slice(2).toLowerCase(),props[key]);}else if(key==='style'&&typeof props[key]==='object'){if(typeof props[key]==='function'){setEffect(()=>{Object.assign(el.style,props[key]());});}else{Object.assign(el.style,props[key]);}}else if(key==='className'||key==='class'){if(typeof props[key]==='function'){setEffect(()=>{el.setAttribute('class',props[key]());});}else{el.setAttribute('class',props[key]);}}else if(typeof props[key]!=='function'){el.setAttribute(key,props[key]);}}if(props.ref&&typeof props.ref==='function'){props.ref(el);}insertChildren(el,props.children);return el;}function h(type,props,...children){props=props||{};if(children.length)props.children=children.length===1?children[0]:children;return jsx(type,props);}return{setSignal,setEffect,setMemo,jsx,h,Fragment};})();

      //prettier-ignore
      const allDungeons = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX', 'XXXI', 'XXXII', 'XXXIII', 'XXXIV', 'XXXV', 'XXXVI', 'XXXVII', 'XXXVIII', 'XXXIX', 'XL', 'XLI', 'XLII', 'XLIII', 'XLIV', 'XLV', 'XLVI', 'XLVII', 'XLVIII', 'XLIX', 'L'];

      const monsterTypes = [
        { name: 'Goblin', baseHp: 20, baseAtk: 5, baseDef: 2, baseDex: 5, sinceLevel: 1 },
        { name: 'Orco', baseHp: 30, baseAtk: 6, baseDef: 4, baseDex: 10, sinceLevel: 5 },
        { name: 'Troll', baseHp: 40, baseAtk: 9, baseDef: 2, baseDex: 5, sinceLevel: 10 },
        { name: 'Minotauro', baseHp: 50, baseAtk: 10, baseDef: 10, baseDex: 2, sinceLevel: 15 },
        { name: 'Demonio', baseHp: 50, baseAtk: 15, baseDef: 3, baseDex: 10, sinceLevel: 15 },
        { name: 'Horror', baseHp: 20, baseAtk: 10, baseDef: 10, baseDex: 35, sinceLevel: 25 },
        { name: 'Lich', baseHp: 50, baseAtk: 10, baseDef: 10, baseDex: 20, sinceLevel: 35 },
        { name: 'Dragón', baseHp: 120, baseAtk: 20, baseDef: 20, baseDex: 5, sinceLevel: 45 },
      ];

      const defaultHero = {
        level: 1,
        hp: 100,
        maxHp: 100,
        atk: 10,
        def: 5,
        dex: 5,
        exp: 0,
        expToNext: 10,
        battlesLeft: 500,
        escapesLeft: 1,
      };
      const defaultBattleLog = [
        { message: 'Nueva partida', className: 'info' },
        { message: 'Explora para empezar', className: 'info' },
      ];

      const dev = {
        isActive: false,
        hero: {
          level: 5,
          hp: 200,
          maxHp: 200,
          atk: 25,
          def: 15,
          dex: 5,
          exp: 200,
          expToNext: 200,
          battlesLeft: 450,
        },
        dungeonIndex: 5,
      };

      function Game() {
        const [hero, setHero] = setSignal(dev.isActive ? dev.hero : defaultHero);

        const [currentDungeonIndex, setCurrentDungeonIndex] = setSignal(dev.isActive ? dev.dungeonIndex : 0);
        const [currentMonsters, setCurrentMonsters] = setSignal([]);
        const [battleLog, setBattleLog] = setSignal(defaultBattleLog);
        const [showLevelUp, setShowLevelUp] = setSignal(false);
        const [didEscape, setDidEscape] = setSignal(false);
        const [canAdvance, setCanAdvance] = setSignal(false);
        const [isAutoExploreActive, setIsAutoExploreActive] = setSignal(false);

        const isInBattle = () => currentMonsters().length > 0;
        const isLevelUp = () => hero().exp >= hero().expToNext;
        const canEscape = () => hero().escapesLeft > 0;

        const generateMonsters = () => {
          const numMonsters = Math.floor(Math.random() * 5) + 1;
          const monsters = [];
          const currentLevel = currentDungeonIndex() + 1;

          const calculateStat = (baseStat, incrementalFactor) => Math.round(baseStat * (1 + currentDungeonIndex() * incrementalFactor));

          for (let i = 0; i < numMonsters; i++) {
            const availableMonsters = monsterTypes.filter(type => type.sinceLevel <= currentLevel);
            const type = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];

            monsters.push({
              ...type,
              hp: calculateStat(type.baseHp, 0.3),
              maxHp: calculateStat(type.baseHp, 0.3),
              atk: calculateStat(type.baseAtk, 0.5),
              def: calculateStat(type.baseDef, 0.5),
              dex: type.baseDex,
            });
          }

          return monsters;
        };

        const checkAndHandleHeroDeath = () => {
          if (hero().hp > 0) return;
          setHero({ ...hero(), isDead: true });
          addToLog({
            message: '¡Héroe derrotado! Fin del juego.',
            className: 'danger',
          });
        };

        const healHero = () => {
          setHero({ ...hero(), hp: hero().maxHp });
          addToLog({
            message: '¡Héroe curado completamente!',
            className: 'success',
          });
        };

        const startBattle = () => {
          if (isInBattle() || isEndGame()) return;

          if (hero().battlesLeft <= 0) {
            addToLog({
              message: '¡Se acabaron tus batallas! Fin del juego.',
              className: 'danger',
            });
            setHero({
              ...hero(),
              isDead: true,
            });
            checkAndHandleHeroDeath();
            return;
          }

          const newMonsters = generateMonsters();
          setCurrentMonsters(newMonsters);
          setDidEscape(false);

          const monsterNames = newMonsters
            .map(m => m.name)
            .join(', ')
            .replace(/, ([^,]+)$/, ' y $1');
          addToLog({
            message: `⚔️ Te encontraste con ${newMonsters.length} ${newMonsters.length === 1 ? 'monstruo' : 'monstruos'}: ${monsterNames}`,
            className: 'warning',
          });
        };

        const handleAutoExplore = e => {
          setIsAutoExploreActive(e.target.checked);
          if (e.target.checked) if (!isInBattle()) startBattle();
        };

        const scrollToLevelUp = () => {
          if (!isLevelUp()) return;
          setTimeout(() => {
            const levelUpBox = document.getElementById('level-up');
            if (levelUpBox) levelUpBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        };

        const isEndGame = () => hero().isDead || hero().isVictory;

        const addToLog = ({ message, className, dontRepeat = false }) => {
          const logEntry = { message, className: className || 'info' };
          if (dontRepeat && battleLog()[battleLog().length - 1]?.message === message) return;

          const newLog = [...battleLog(), logEntry];
          if (newLog.length > 1000) newLog.splice(0, 1);
          setBattleLog(newLog);
        };

        const calculateExp = monster => {
          const baseExp = monster.maxHp * monster.atk * monster.def * monster.dex;
          let exp = baseExp / 1000;

          return Math.round(exp);
        };

        const calculateDamage = (atk, targetDef, dex, isMonsterAttack = false) => {
          const dungeonLevel = currentDungeonIndex() + 1;
          const critChance = isMonsterAttack ? dex : dex;
          const isCritical = Math.random() * 100 < critChance;

          const baseDamage = isCritical ? atk * 1.4 : atk * (0.6 + Math.random() * 0.8); //Critical damage always max

          const netDamage = Math.max(1, baseDamage - targetDef);

          const finalDamage = isCritical ? netDamage * 2 : netDamage; //Critical gets double final damage

          return { damage: Math.round(finalDamage), isCritical };
        };

        const attack = () => {
          if (hero().isDead || !isInBattle()) return;

          const monster = currentMonsters()[0];
          const { damage, isCritical } = calculateDamage(hero().atk, monster.def, hero().dex);
          monster.hp = Math.max(0, monster.hp - damage);
          addToLog({
            message: `Héroe → ${monster.name} ${isCritical ? '| ¡CRÍTICO!' : ''} | ${damage} DAÑO (${monster.hp}/${monster.maxHp} HP)`,
            className: isCritical ? 'info-success' : 'info',
          });

          if (monster.hp <= 0) {
            const expGained = calculateExp(monster);
            setHero({
              ...hero(),
              exp: hero().exp + expGained,
            });
            addToLog({
              message: `${monster.name} derrotado +${expGained} EXP ${
                currentMonsters().length > 1
                  ? `| Queda${currentMonsters().length - 1 === 1 ? '' : 'n'} ${currentMonsters().length - 1} monstruo${
                      currentMonsters().length - 1 === 1 ? '' : 's'
                    }`
                  : ''
              }`,
              className: 'info-success',
            });

            setCurrentMonsters(currentMonsters().filter(m => m !== monster));

            if (currentMonsters().length === 0) endBattle();

            return;
          }

          const { damage: monsterDamage, isCritical: monsterIsCritical } = calculateDamage(monster.atk, hero().def, monster.dex, true);
          setHero({
            ...hero(),
            hp: Math.max(0, hero().hp - monsterDamage),
          });

          const damagePercentage = (monsterDamage / hero().maxHp) * 100;
          let damageClass = 'info-warning';
          if (damagePercentage > 10) damageClass = 'danger';
          else if (damagePercentage > 3) damageClass = 'info-danger';

          addToLog({
            message: `${monster.name} → Héroe ${monsterIsCritical ? '| ¡CRÍTICO!' : ''} | ${monsterDamage} DAÑO.`,
            className: damageClass,
          });

          checkAndHandleHeroDeath();
        };

        const escape = () => {
          if (!canEscape() || hero().isDead || !isInBattle()) return;

          addToLog({
            message: `¡Escapaste!${isAutoExploreActive() ? ' (Auto-explorar desactivado)' : ''}`,
            className: 'success',
          });
          setCurrentMonsters([]);
          setDidEscape(true);
          setHero({
            ...hero(),
            escapesLeft: hero().escapesLeft - 1,
          });
          healHero();
          if (isAutoExploreActive()) document.getElementById('auto-explore').click();
          endBattle();
        };

        const endBattle = () => {
          if (!didEscape()) {
            if (!canAdvance()) {
              addToLog({
                message: 'Victoria. Puedes avanzar a la siguiente mazmorra!',
                className: 'success',
              });
              setCanAdvance(true);
            } else {
              addToLog({
                message: 'Victoria. Batalla terminada.',
                className: 'success',
              });
            }

            if (isAutoExploreActive() && !isEndGame()) {
              addToLog({
                message: 'Exploración automática...',
                className: 'info-warning',
              });
              setTimeout(startBattle, 1000);
            }
          }
          if (isLevelUp()) {
            setShowLevelUp(true);
            addToLog({
              message: `¡Subiste al nivel ${hero().level + 1}!`,
              className: 'success',
            });
          }
          setHero({
            ...hero(),
            battlesLeft: hero().battlesLeft - 1,
          });
        };

        const advanceDungeon = () => {
          if (isInBattle() || isEndGame() || isAutoExploreActive() || !canAdvance()) {
            addToLog({
              message: 'No puedes avanzar, estas en una batalla!',
              className: 'info-warning',
              dontRepeat: true,
            });
            return;
          }

          if (!canAdvance()) {
            addToLog({
              message: `¡No puedes avanzar a la siguiente mazmorra aún! Debes ganar al menos 1 batalla`,
              className: 'info-warning',
              dontRepeat: true,
            });
            return;
          } else if (currentDungeonIndex() === allDungeons.length - 2) {
            addToLog({
              message: `¡Has superado todas las mazmorras! Ganaste el juego, felicidades.`,
              className: 'success',
              dontRepeat: true,
            });
            setHero({
              ...hero(),
              isVictory: true,
            });
          } else {
            healHero();
            setCurrentDungeonIndex(currentDungeonIndex() + 1);
            setCanAdvance(false);
            addToLog({
              message: `¡Avanzaste a la Mazmorra ${allDungeons[currentDungeonIndex()]}!`,
              className: 'success',
              dontRepeat: true,
            });
          }
        };

        const levelUp = stat => {
          const newHero = {
            ...hero(),
            level: hero().level + 1,
            exp: hero().exp - hero().expToNext,
            expToNext: Math.floor(hero().expToNext * 1.35),
            escapesLeft: hero().escapesLeft + 1,
          };

          switch (stat) {
            case 'hp':
              newHero.maxHp += 15;
              newHero.hp = newHero.maxHp;
              break;
            case 'atk':
              newHero.atk += 2;
              break;
            case 'def':
              newHero.def += 2;
              break;
            case 'dex':
              newHero.dex += 2;
              break;
          }

          setHero(newHero);
          setShowLevelUp(false);
          healHero();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        const resetGame = () => {
          setHero(defaultHero);
          setCurrentDungeonIndex(0);
          setCurrentMonsters([]);
          setBattleLog(defaultBattleLog);
          setShowLevelUp(false);
          setDidEscape(false);
          setCanAdvance(false);
        };

        return h(
          Fragment,
          null,
          h(
            'div',
            { className: 'container' },
            h('h1', { className: 'title' }, 'Mini RPG'),
            h('h2', { className: () => (hero().isDead ? 'game-over' : hero().isVictory ? 'game-victory' : 'game-status') }, () =>
              hero().isDead
                ? '¡Héroe derrotado! Fin del juego.'
                : hero().isVictory
                ? 'Ganaste el juego, felicidades.'
                : `Mazmorra ${allDungeons[currentDungeonIndex()]} — Batalla ${500 - hero().battlesLeft + 1} / 500`
            ),
            h('div', { className: 'stats' }, [
              h('div', null, () => `Nivel: ${hero().level}`),
              h('div', { className: () => (hero().hp / hero().maxHp <= 0.35 ? 'low-hp' : '') }, () => `HP: ${hero().hp}/${hero().maxHp}`),
              h('div', null, () => `ATK: ${hero().atk}`),
              h('div', null, () => `DEF: ${hero().def}`),
              h('div', null, () => `DEX: ${hero().dex}`),
              h(
                'div',
                {
                  className: () => (isLevelUp() ? (!isInBattle() ? 'ready-to-level-button' : 'ready-to-level') : ''),
                  onclick: scrollToLevelUp,
                },
                () => (isLevelUp() && !isInBattle() ? 'Level Up!' : `EXP: ${hero().exp}/${hero().expToNext}`)
              ),
            ]),
            h(
              'div',
              { className: 'battle-log' },
              Array.from({ length: 50 }, (_, i) =>
                h(
                  'div',
                  { key: i, className: () => `message ${battleLog()[battleLog().length - i - 1]?.className}` },
                  () => battleLog()[battleLog().length - i - 1]?.message
                )
              )
            ),
            h('div', { className: 'actions-grid' }, [
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  { className: () => (isEndGame() || !isInBattle() ? 'disabled btn-attack' : 'btn-attack'), onclick: attack },
                  'Atacar'
                ),
              ]),
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  {
                    className: () => (!canEscape() || isEndGame() || !isInBattle() ? 'disabled btn-escape' : 'btn-escape'),
                    onclick: escape,
                  },
                  () => `Escapar [ ${hero().escapesLeft} ]`
                ),
                h(
                  'button',
                  {
                    className: () => (isInBattle() || isEndGame() || isAutoExploreActive() ? 'disabled btn-explore' : 'btn-explore'),
                    onclick: startBattle,
                  },
                  'Explorar'
                ),
              ]),
              h('div', { className: 'actions-row' }, [
                h(
                  'button',
                  {
                    className: () =>
                      isInBattle() || isEndGame() || isAutoExploreActive() || !canAdvance() ? 'disabled btn-advance' : 'btn-advance',
                    onclick: advanceDungeon,
                  },
                  'Avanzar Mazmorra'
                ),
              ]),
              h('button', { className: () => (isEndGame() ? 'btn-reset' : 'hidden'), onclick: resetGame }, 'Empezar de nuevo'),
            ]),
            h('div', { className: 'auto-explore' }, [
              h('div', { className: 'auto-explore-checkbox' }, [
                h('input', { type: 'checkbox', id: 'auto-explore', onchange: handleAutoExplore }),
                h('label', { for: 'auto-explore' }, 'Auto-Explorar'),
              ]),
              h(
                'p',
                { className: 'auto-explore-helper-text' },
                'Explorar automáticamente después de cada victoria. Se desactiva al escapar.'
              ),
            ]),
            h('div', { id: 'level-up', className: () => (!isEndGame() && showLevelUp() ? 'level-up visible' : 'level-up') }, [
              h('h2', null, '¡Subiste de nivel!'),
              h(
                'div',
                { style: 'display: flex; justify-content: center; gap: 1rem; margin: 1rem 0; font-size: 0.9em; font-style: italic;' },
                [
                  h('div', null, () => `HP: ${hero().maxHp}`),
                  h('div', null, () => `|`),
                  h('div', null, () => `ATK: ${hero().atk}`),
                  h('div', null, () => `|`),
                  h('div', null, () => `DEF: ${hero().def}`),
                  h('div', null, () => `|`),
                  h('div', null, () => `DEX: ${hero().dex}`),
                ]
              ),
              h('button', { onclick: () => levelUp('hp') }, 'Aumentar HP'),
              h('button', { onclick: () => levelUp('atk') }, 'Aumentar ATK'),
              h('button', { onclick: () => levelUp('def') }, 'Aumentar DEF'),
              h('button', { onclick: () => levelUp('dex') }, 'Aumentar DEX'),
            ])
          ),
          h('div', { className: 'container info-section' }, [
            h('h2', null, 'Información y Preguntas Frecuentes'),
            h('div', { className: 'info-content' }, [
              h('h3', null, 'Objetivo'),
              h('p', null, 'Supera las 50 mazmorras antes de agotar tus 500 batallas disponibles.'),
              h('h3', null, '¿Cómo jugar?'),
              h('p', null, '1. Busca enemigos usando el botón "Explorar".'),
              h('p', null, '2. Cada batalla tiene varios monstruos. Mátalos todos para ganar la batalla.'),
              h('p', null, '3. Gana EXP y sube de nivel para mejorar tus stats.'),
              h('p', null, '4. Gana una batalla en cada mazmorra para avanzar a la siguiente.'),
              h('h3', null, 'Mecánicas importantes'),
              h(
                'p',
                null,
                '- HP es la vida del héroe. ATK aumenta el daño. DEF disminuye el daño recibido. DEX aumenta la probabilidad de crítico (mucho más daño)'
              ),
              h('p', null, '- El héroe se cura al subir de nivel, avanzar de mazmorra o escapar.'),
              h('p', null, '- Obtienes un escape cada vez que subes de nivel. Úsalos sabiamente!'),
              h('p', null, '- La probabilidad de escape aumenta con tu nivel y baja con la mazmorra y el número de monstruos vivos.'),
              h('p', null, '- El héroe sólo sube de nivel al terminar batallas, ya sea escapando o ganando.'),
              h('h3', null, 'Otras mecánicas'),
              h('p', null, '- Cuando el indicador de EXP esté verde, puedes hacerle click para scrollear hasta el selector de level-up.'),
              h('h3', null, 'Consejos'),
              h('p', null, '- No subestimes una retirada táctica para seguir con vida. Especialmente útil para activar un level-up.'),
              h(
                'p',
                null,
                '- Puedes guardar la subida de nivel para cuando tengas vida baja para curarte. Sólo sube 1 nivel a la vez, así que no guardes mucha experiencia.'
              ),
            ]),
          ])
        );
      }

      const root = document.body;
      root.appendChild(Game());
    </script>
  </body>
</html>
