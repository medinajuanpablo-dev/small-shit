<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini RPG</title>
    <style>
      body {
        background: linear-gradient(135deg, #1a2a3a 0%, #2c3e50 100%);
        color: #ecf0f1;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        text-align: center;
        padding: 10px;
        min-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .container {
        background: rgba(52, 73, 94, 0.9);
        padding: clamp(1rem, 3vw, 2rem);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        max-width: 800px;
        width: 95%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 0.5rem;
        margin: 1rem 0;
        padding: clamp(0.8rem, 2vw, 1rem);
        background: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
      }
      .battle-log {
        height: clamp(150px, 40vh, 400px);
        overflow-y: auto;
        background: rgba(44, 62, 80, 0.7);
        padding: clamp(0.8rem, 2vw, 1rem);
        border-radius: 15px;
        margin: 1rem 0;
        text-align: left;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .battle-log .message {
        margin: 0.3rem 0;
      }
      .battle-log .success {
        color: #2ecc71;
      }
      .battle-log .error {
        color: #e74c3c;
      }
      .battle-log .warning {
        color: #f1c40f;
      }
      .battle-log .info {
        color: #87ceeb;
      }
      button {
        padding: clamp(0.5rem, 2vw, 0.8rem) clamp(1rem, 4vw, 1.5rem);
        margin: 0.5rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 300px;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        background: linear-gradient(145deg, #2980b9, #3498db);
      }
      .monster {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 0.5rem;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .level-up {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 1rem 0;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .level-up.visible {
        visibility: visible;
        opacity: 1;
      }
      button:disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .game-status {
        color: #3498db;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-over {
        color: #e74c3c;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-victory {
        color: #2ecc71;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .info-section {
        margin-top: 2rem;
        padding: 1rem;
        background-color: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .info-content {
        text-align: left;
        padding: 1rem;
      }
      .info-content h3 {
        color: #3498db;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .info-content p {
        margin: 0.5rem 0;
        line-height: 1.4;
      }
      .info-content h2 {
        color: #2ecc71;
        margin-bottom: 1rem;
      }
      .stats .low-hp {
        color: #e74c3c;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
      }
      .stats .ready-to-level {
        color: #2ecc71;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
      }
      .hidden {
        display: none;
      }

      @media (max-width: 700px) {
        body {
          padding-top: 0px;
          padding-bottom: 0px;
        }
        .container {
          padding: 0.8rem;
          width: 100%;
          border-radius: 0;
          margin: 0.5rem 0;
        }
        .stats {
          grid-template-columns: repeat(2, 1fr);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        button {
          width: 100%;
        }
        .battle-log {
          height: clamp(120px, 70vh, 180px);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        .info-section {
          margin-top: 1rem;
          padding: 0.8rem;
        }
        .info-content {
          padding: 0.8rem;
        }
        .info-content h3 {
          margin-top: 1rem;
          margin-bottom: 0.3rem;
        }
        .info-content p {
          margin: 0.3rem 0;
        }
      }
    </style>
  </head>
  <body>
    <script type="module">
      //prettier-ignore
      const { Fragment, setSignal, h } = (() => {let currentObserver=null;function setSignal(value){const subscribers=new Set();const read=()=>{if(currentObserver)subscribers.add(currentObserver);return value;};const write=newValue=>{value=typeof newValue==='function'?newValue(value):newValue;subscribers.forEach(fn=>fn());};return[read,write];}function setEffect(fn){const execute=()=>{currentObserver=execute;fn();currentObserver=null;};execute();}function setMemo(fn){const[get,set]=setSignal();setEffect(()=>set(fn()));return get;}const SVG_NS='http://www.w3.org/2000/svg';const isSvg=tag=>/^(svg|path|circle|rect|line|polygon|polyline|ellipse|g|text|defs|use)$/.test(tag);function Fragment(props){const fragment=document.createDocumentFragment();insertChildren(fragment,props.children);return fragment;}function insertChildren(parent,children){if(!children)return;const childArray=Array.isArray(children)?children.flat():[children];for(const child of childArray){if(child==null||typeof child==='boolean')continue;if(typeof child==='function'){const marker=document.createComment('');let lastValue=null;parent.appendChild(marker);setEffect(()=>{const value=child();if(value===lastValue)return;lastValue=value;let node;while((node=marker.nextSibling)&&node.nodeType!==8)node.remove();if(value==null)return;if(typeof value==='object'&&value.nodeType){parent.insertBefore(value,marker.nextSibling);}else if(typeof value!=='object'){parent.insertBefore(document.createTextNode(String(value)),marker.nextSibling);}});}else if(typeof child==='object'&&child.nodeType){parent.appendChild(child);}else{parent.appendChild(document.createTextNode(String(child)));}}}function jsx(type,props={}){if(typeof type==='function')return type(props);if(type===Fragment)return Fragment(props);const el=isSvg(type)?document.createElementNS(SVG_NS,type):document.createElement(type);for(const key in props){if(key==='children'||key==='ref')continue;if(key.startsWith('on')&&typeof props[key]==='function'){el.addEventListener(key.slice(2).toLowerCase(),props[key]);}else if(key==='style'&&typeof props[key]==='object'){if(typeof props[key]==='function'){setEffect(()=>{Object.assign(el.style,props[key]());});}else{Object.assign(el.style,props[key]);}}else if(key==='className'||key==='class'){if(typeof props[key]==='function'){setEffect(()=>{el.setAttribute('class',props[key]());});}else{el.setAttribute('class',props[key]);}}else if(typeof props[key]!=='function'){el.setAttribute(key,props[key]);}}if(props.ref&&typeof props.ref==='function'){props.ref(el);}insertChildren(el,props.children);return el;}function h(type,props,...children){props=props||{};if(children.length)props.children=children.length===1?children[0]:children;return jsx(type,props);}return{setSignal,setEffect,setMemo,jsx,h,Fragment};})();

      const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];

      const monsterTypes = [
        { name: 'Goblin', baseHp: 20, baseAtk: 5, baseDef: 2, sinceLevel: 1 },
        { name: 'Orco', baseHp: 30, baseAtk: 6, baseDef: 4, sinceLevel: 1 },
        { name: 'Troll', baseHp: 40, baseAtk: 9, baseDef: 2, sinceLevel: 2 },
        { name: 'Minotauro', baseHp: 50, baseAtk: 12, baseDef: 6, sinceLevel: 3 },
        { name: 'Dragón', baseHp: 70, baseAtk: 15, baseDef: 8, sinceLevel: 4 },
        { name: 'Lich', baseHp: 60, baseAtk: 18, baseDef: 5, sinceLevel: 5 },
      ];

      function Game() {
        const [hero, setHero] = setSignal({
          level: 1,
          hp: 100,
          maxHp: 100,
          atk: 10,
          def: 5,
          exp: 0,
          expToNext: 100,
          battlesLeft: 100,
          isDead: false,
          isVictory: false,
        });

        const [currentDungeon, setCurrentDungeon] = setSignal(0);
        const [currentMonsters, setCurrentMonsters] = setSignal([]);
        const [battleLog, setBattleLog] = setSignal([{ message: 'Nueva partida', className: 'info' }]);
        const [showLevelUp, setShowLevelUp] = setSignal(false);
        const [didEscape, setDidEscape] = setSignal(false);
        const [canAdvance, setCanAdvance] = setSignal(false);

        const generateMonsters = () => {
          const numMonsters = Math.floor(Math.random() * 5) + 1;
          const monsters = [];
          const currentLevel = currentDungeon() + 1;

          for (let i = 0; i < numMonsters; i++) {
            const availableMonsters = monsterTypes.filter(type => type.sinceLevel <= currentLevel);
            const type = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
            const modifier = currentLevel;

            monsters.push({
              ...type,
              hp: Math.round(type.baseHp * modifier),
              maxHp: Math.round(type.baseHp * modifier),
              atk: Math.round(type.baseAtk * modifier),
              def: Math.round(type.baseDef * modifier),
            });
          }

          return monsters;
        };

        const checkAndHandleHeroDeath = () => {
          if (hero().hp > 0) return;
          setHero({ ...hero(), isDead: true });
          addToLog({
            message: '¡Héroe derrotado! Fin del juego.',
            className: 'error',
          });
        };

        const healHero = () => {
          setHero({ ...hero(), hp: hero().maxHp });
          addToLog({
            message: '¡Héroe curado completamente!',
            className: 'success',
          });
        };

        const startBattle = () => {
          if (hero().isDead) return;

          if (hero().battlesLeft <= 0) {
            addToLog({
              message: '¡Se acabaron tus batallas! Fin del juego.',
              className: 'error',
            });
            setHero({
              ...hero(),
              isDead: true,
            });
            checkAndHandleHeroDeath();
            return;
          }

          if (currentMonsters().length > 0) {
            addToLog({
              message: '¡Estás en una batalla!',
              className: 'error',
            });
            return;
          }

          const newMonsters = generateMonsters();
          setCurrentMonsters(newMonsters);
          setDidEscape(false);

          const monsterNames = newMonsters.map(m => m.name).join(', ');
          addToLog({
            message: `Te has encontrado con: ${monsterNames}`,
            className: 'warning',
          });
        };

        const addToLog = message => {
          const logEntry = typeof message === 'string' ? { message, className: 'info' } : message;
          setBattleLog([...battleLog(), logEntry]);
        };

        const attack = () => {
          if (hero().isDead || currentMonsters().length === 0) return;

          const monster = currentMonsters()[0];
          const damage = Math.max(1, hero().atk - monster.def);
          monster.hp -= damage;
          addToLog({
            message: `Héroe ataca a ${monster.name} por ${damage} de daño (${monster.hp}/${monster.maxHp} HP)`,
            className: 'info',
          });

          const monsterDamage = Math.max(1, monster.atk - hero().def);
          setHero({
            ...hero(),
            hp: Math.max(0, hero().hp - monsterDamage),
          });
          addToLog({
            message: `${monster.name} ataca al héroe por ${monsterDamage} de daño`,
            className: 'warning',
          });

          if (monster.hp <= 0) {
            const expGained = monster.maxHp * (currentDungeon() + 1);
            setHero({
              ...hero(),
              exp: hero().exp + expGained,
            });
            addToLog({
              message: `${monster.name} derrotado! +${expGained} EXP. ${
                currentMonsters().length > 1
                  ? `Queda${currentMonsters().length - 1 === 1 ? '' : 'n'} ${currentMonsters().length - 1} monstruo${
                      currentMonsters().length - 1 === 1 ? '' : 's'
                    }`
                  : ''
              }`,
              className: 'info',
            });

            setCurrentMonsters(currentMonsters().filter(m => m !== monster));

            if (currentMonsters().length === 0) {
              endBattle();
            }
          }

          checkAndHandleHeroDeath();
        };

        const escape = () => {
          if (hero().isDead || currentMonsters().length === 0) return;

          const baseEscapeChance = 0.9; // 90% base
          const heroLevelBonus = hero().level * 0.1; // +10% por nivel
          const dungeonPenalty = currentDungeon() * 0.1; // -10% por nivel de mazmorra
          const monsterCountPenalty = currentMonsters().length * 0.1; // -10% por monstruo

          const escapeChance = Math.max(0.1, Math.min(0.9, baseEscapeChance + heroLevelBonus - dungeonPenalty - monsterCountPenalty));

          if (Math.random() < escapeChance) {
            addToLog({
              message: `¡Escape exitoso! (Probabilidad: ${Math.round(escapeChance * 100)}%)`,
              className: 'success',
            });
            setCurrentMonsters([]);
            setDidEscape(true);
            endBattle();
          } else {
            addToLog({
              message: `¡Escape fallido! (Probabilidad: ${Math.round(escapeChance * 100)}%)`,
              className: 'error',
            });
            const monster = currentMonsters()[0];
            const damage = Math.max(1, monster.atk - hero().def);
            setHero({
              ...hero(),
              hp: Math.max(0, hero().hp - damage),
            });
            addToLog({
              message: `${monster.name} ataca al héroe por ${damage} de daño`,
              className: 'error',
            });

            checkAndHandleHeroDeath();
          }
        };

        const endBattle = () => {
          if (!didEscape()) {
            if (!canAdvance()) {
              addToLog({
                message: 'Victoria. Puedes avanzar a la siguiente mazmorra!',
                className: 'success',
              });
              setCanAdvance(true);
            } else {
              addToLog({
                message: 'Victoria. Batalla terminada.',
                className: 'success',
              });
            }
          }
          if (hero().exp >= hero().expToNext) {
            setShowLevelUp(true);
            addToLog({
              message: `¡Subiste al nivel ${hero().level + 1}!`,
              className: 'success',
            });
          }
          setHero({
            ...hero(),
            battlesLeft: hero().battlesLeft - 1,
          });
        };

        const advanceDungeon = () => {
          if (!canAdvance()) {
            addToLog({
              message: `¡No puedes avanzar a la siguiente mazmorra aún! Debes ganar al menos 1 batalla`,
              className: 'error',
            });
            return;
          } else if (currentDungeon() === 8) {
            addToLog({
              message: `¡Has superado todas las mazmorras! Ganaste el juego, felicidades.`,
              className: 'success',
            });
            setHero({
              ...hero(),
              isVictory: true,
            });
          } else {
            healHero();
            setCurrentDungeon(currentDungeon() + 1);
            setCanAdvance(false);
            addToLog({
              message: `¡Avanzaste a la Mazmorra ${romanNumerals[currentDungeon()]}!`,
              className: 'success',
            });
          }
        };

        const levelUp = stat => {
          const newHero = {
            ...hero(),
            level: hero().level + 1,
            exp: hero().exp - hero().expToNext,
            expToNext: Math.floor(hero().expToNext * 1.5),
          };

          switch (stat) {
            case 'hp':
              newHero.maxHp += 35;
              newHero.hp = newHero.maxHp;
              break;
            case 'atk':
              newHero.atk += 5;
              break;
            case 'def':
              newHero.def += 5;
              break;
          }

          setHero(newHero);
          setShowLevelUp(false);
          healHero();
        };

        const resetGame = () => {
          setHero({
            level: 1,
            hp: 100,
            maxHp: 100,
            atk: 10,
            def: 5,
            exp: 0,
            expToNext: 100,
            battlesLeft: 100,
            isDead: false,
          });
          setCurrentDungeon(0);
          setCurrentMonsters([]);
          setBattleLog([]);
          setShowLevelUp(false);
          setDidEscape(false);
          setCanAdvance(false);
          addToLog({
            message: 'Nueva partida',
            className: 'info',
          });
        };

        const isEndGame = () => hero().isDead || hero().isVictory;

        return h(
          Fragment,
          null,
          h(
            'div',
            { className: 'container' },
            h('h1', null, 'Mini RPG'),
            h('h2', { className: () => (hero().isDead ? 'game-over' : hero().isVictory ? 'game-victory' : 'game-status') }, () =>
              hero().isDead
                ? '¡Héroe derrotado! Fin del juego.'
                : hero().isVictory
                ? 'Ganaste el juego, felicidades.'
                : `Mazmorra ${romanNumerals[currentDungeon()]}`
            ),
            h('div', { className: 'stats' }, [
              h('div', null, () => `Nivel: ${hero().level}`),
              h('div', { className: () => (hero().hp / hero().maxHp <= 0.35 ? 'low-hp' : '') }, () => `HP: ${hero().hp}/${hero().maxHp}`),
              h('div', null, () => `ATK: ${hero().atk}`),
              h('div', null, () => `DEF: ${hero().def}`),
              h(
                'div',
                { className: () => (hero().exp >= hero().expToNext ? 'ready-to-level' : '') },
                () => `EXP: ${hero().exp}/${hero().expToNext}`
              ),
              h('div', null, () => `Batallas: ${hero().battlesLeft}`),
            ]),
            h(
              'div',
              { className: 'battle-log' },
              Array.from({ length: 50 }, (_, i) =>
                h(
                  'div',
                  { key: i, className: () => `message ${battleLog()[battleLog().length - i - 1]?.className}` },
                  () => battleLog()[battleLog().length - i - 1]?.message
                )
              )
            ),
            h('div', null, [
              h('button', { className: () => (isEndGame() ? '' : 'hidden'), onclick: resetGame }, 'Empezar de nuevo'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: startBattle }, 'Explorar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: attack }, 'Atacar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: escape }, 'Escapar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: advanceDungeon }, 'Avanzar Mazmorra'),
            ]),
            h('div', { id: 'level-up', className: () => (!isEndGame() && showLevelUp() ? 'level-up visible' : 'level-up') }, [
              h('h2', null, '¡Subiste de nivel!'),
              h('button', { onclick: () => levelUp('hp') }, 'Aumentar HP'),
              h('button', { onclick: () => levelUp('atk') }, 'Aumentar ATK'),
              h('button', { onclick: () => levelUp('def') }, 'Aumentar DEF'),
            ])
          ),
          h('div', { className: 'container info-section' }, [
            h('h2', null, 'Información y Preguntas Frecuentes'),
            h('div', { className: 'info-content' }, [
              h('h3', null, 'Objetivo'),
              h('p', null, 'Supera las 10 mazmorras antes de agotar tus 100 batallas disponibles.'),
              h('h3', null, '¿Cómo jugar?'),
              h('p', null, '1. Inicia una batalla usando el botón "Iniciar Batalla".'),
              h('p', null, '2. Cada batalla tiene varios monstruos. Mátalos todos para ganar batallas.'),
              h('p', null, '3. Gana experiencia y sube de nivel.'),
              h('p', null, '4. Avanza a mazmorras más difíciles.'),
              h('h3', null, 'Mecánicas importantes'),
              h('p', null, '- El héroe se cura sólo al subir de nivel y al avanzar de mazmorra.'),
              h('p', null, '- La probabilidad de escape depende de tu nivel, la mazmorra y el número de monstruos vivos.'),
              h('p', null, '- El héroe sólo sube de nivel al terminar batallas, ya sea escapando o ganando.'),
              h('h3', null, 'Consejos'),
              h('p', null, '- No subestimes una retirada táctica para seguir con vida.'),
              h(
                'p',
                null,
                '- Puedes guardar la subida de nivel para cuando tengas vida baja para curarte. Sólo sube 1 nivel a la vez, así que no guardes mucha experiencia.'
              ),
            ]),
          ])
        );
      }

      const root = document.body;
      root.appendChild(Game());
    </script>
  </body>
</html>
