<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini RPG</title>
    <style>
      body {
        background: linear-gradient(135deg, #1a2a3a 0%, #2c3e50 100%);
        color: #ecf0f1;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        text-align: center;
        padding: 10px;
        min-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .container {
        background: rgba(52, 73, 94, 0.9);
        padding: clamp(1rem, 3vw, 2rem);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        max-width: 800px;
        width: 95%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 0.5rem;
        margin: 1rem 0;
        padding: clamp(0.8rem, 2vw, 1rem);
        background: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
      }
      .battle-log {
        height: clamp(150px, 40vh, 400px);
        overflow-y: auto;
        background: rgba(44, 62, 80, 0.7);
        padding: clamp(0.8rem, 2vw, 1rem);
        border-radius: 15px;
        margin: 1rem 0;
        text-align: left;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .battle-log .message {
        margin: 0.3rem 0;
      }
      .battle-log .success {
        color: #2ecc71;
      }
      .battle-log .error {
        color: #e74c3c;
      }
      .battle-log .warning {
        color: #f1c40f;
      }
      .battle-log .info {
        color: #87ceeb;
      }
      button {
        padding: clamp(0.5rem, 2vw, 0.8rem) clamp(1rem, 4vw, 1.5rem);
        margin: 0.5rem;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 300px;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        background: linear-gradient(145deg, #2980b9, #3498db);
      }
      .monster {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 0.5rem;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .level-up {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        padding: clamp(0.8rem, 2vw, 1rem);
        margin: 1rem 0;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .level-up.visible {
        visibility: visible;
        opacity: 1;
      }
      button:disabled {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .game-status {
        color: #3498db;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-over {
        color: #e74c3c;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .game-victory {
        color: #2ecc71;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .info-section {
        margin-top: 2rem;
        padding: 1rem;
        background-color: rgba(44, 62, 80, 0.7);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .info-content {
        text-align: left;
        padding: 1rem;
      }
      .info-content h3 {
        color: #3498db;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .info-content p {
        margin: 0.5rem 0;
        line-height: 1.4;
      }
      .info-content h2 {
        color: #2ecc71;
        margin-bottom: 1rem;
      }
      .stats .low-hp {
        color: #e74c3c;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
      }
      .stats .ready-to-level {
        color: #2ecc71;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
      }
      .hidden {
        display: none;
      }

      @media (max-width: 700px) {
        body {
          padding-top: 0px;
          padding-bottom: 0px;
        }
        .container {
          padding: 0.8rem;
          width: 100%;
          border-radius: 0;
          margin: 0.5rem 0;
        }
        .stats {
          grid-template-columns: repeat(2, 1fr);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        button {
          width: 100%;
        }
        .battle-log {
          height: clamp(120px, 70vh, 180px);
          margin: 0.5rem 0;
          padding: 0.6rem;
        }
        .info-section {
          margin-top: 1rem;
          padding: 0.8rem;
        }
        .info-content {
          padding: 0.8rem;
        }
        .info-content h3 {
          margin-top: 1rem;
          margin-bottom: 0.3rem;
        }
        .info-content p {
          margin: 0.3rem 0;
        }
      }
    </style>
  </head>
  <body>
    <script type="module">
      //prettier-ignore
      const { Fragment, setSignal, h } = (() => {let currentObserver=null;function setSignal(value){const subscribers=new Set();const read=()=>{if(currentObserver)subscribers.add(currentObserver);return value;};const write=newValue=>{value=typeof newValue==='function'?newValue(value):newValue;subscribers.forEach(fn=>fn());};return[read,write];}function setEffect(fn){const execute=()=>{currentObserver=execute;fn();currentObserver=null;};execute();}function setMemo(fn){const[get,set]=setSignal();setEffect(()=>set(fn()));return get;}const SVG_NS='http://www.w3.org/2000/svg';const isSvg=tag=>/^(svg|path|circle|rect|line|polygon|polyline|ellipse|g|text|defs|use)$/.test(tag);function Fragment(props){const fragment=document.createDocumentFragment();insertChildren(fragment,props.children);return fragment;}function insertChildren(parent,children){if(!children)return;const childArray=Array.isArray(children)?children.flat():[children];for(const child of childArray){if(child==null||typeof child==='boolean')continue;if(typeof child==='function'){const marker=document.createComment('');let lastValue=null;parent.appendChild(marker);setEffect(()=>{const value=child();if(value===lastValue)return;lastValue=value;let node;while((node=marker.nextSibling)&&node.nodeType!==8)node.remove();if(value==null)return;if(typeof value==='object'&&value.nodeType){parent.insertBefore(value,marker.nextSibling);}else if(typeof value!=='object'){parent.insertBefore(document.createTextNode(String(value)),marker.nextSibling);}});}else if(typeof child==='object'&&child.nodeType){parent.appendChild(child);}else{parent.appendChild(document.createTextNode(String(child)));}}}function jsx(type,props={}){if(typeof type==='function')return type(props);if(type===Fragment)return Fragment(props);const el=isSvg(type)?document.createElementNS(SVG_NS,type):document.createElement(type);for(const key in props){if(key==='children'||key==='ref')continue;if(key.startsWith('on')&&typeof props[key]==='function'){el.addEventListener(key.slice(2).toLowerCase(),props[key]);}else if(key==='style'&&typeof props[key]==='object'){if(typeof props[key]==='function'){setEffect(()=>{Object.assign(el.style,props[key]());});}else{Object.assign(el.style,props[key]);}}else if(key==='className'||key==='class'){if(typeof props[key]==='function'){setEffect(()=>{el.setAttribute('class',props[key]());});}else{el.setAttribute('class',props[key]);}}else if(typeof props[key]!=='function'){el.setAttribute(key,props[key]);}}if(props.ref&&typeof props.ref==='function'){props.ref(el);}insertChildren(el,props.children);return el;}function h(type,props,...children){props=props||{};if(children.length)props.children=children.length===1?children[0]:children;return jsx(type,props);}return{setSignal,setEffect,setMemo,jsx,h,Fragment};})();

      const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];

      const monsterTypes = [
        { name: 'Goblin', baseHp: 20, baseAtk: 5, baseDef: 2, sinceLevel: 1 },
        { name: 'Orco', baseHp: 30, baseAtk: 6, baseDef: 4, sinceLevel: 1 },
        { name: 'Troll', baseHp: 40, baseAtk: 9, baseDef: 2, sinceLevel: 2 },
        { name: 'Minotauro', baseHp: 50, baseAtk: 12, baseDef: 6, sinceLevel: 3 },
        { name: 'Drag√≥n', baseHp: 70, baseAtk: 15, baseDef: 8, sinceLevel: 4 },
        { name: 'Lich', baseHp: 60, baseAtk: 18, baseDef: 5, sinceLevel: 5 },
      ];

      function Game() {
        const [hero, setHero] = setSignal({
          level: 1,
          hp: 100,
          maxHp: 100,
          atk: 10,
          def: 5,
          exp: 0,
          expToNext: 100,
          battlesLeft: 100,
          isDead: false,
          isVictory: false,
        });

        const [currentDungeon, setCurrentDungeon] = setSignal(0);
        const [currentMonsters, setCurrentMonsters] = setSignal([]);
        const [battleLog, setBattleLog] = setSignal([{ message: 'Nueva partida', className: 'info' }]);
        const [showLevelUp, setShowLevelUp] = setSignal(false);
        const [didEscape, setDidEscape] = setSignal(false);
        const [canAdvance, setCanAdvance] = setSignal(false);

        const generateMonsters = () => {
          const numMonsters = Math.floor(Math.random() * 5) + 1;
          const monsters = [];
          const currentLevel = currentDungeon() + 1;

          for (let i = 0; i < numMonsters; i++) {
            const availableMonsters = monsterTypes.filter(type => type.sinceLevel <= currentLevel);
            const type = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
            const modifier = currentLevel;

            monsters.push({
              ...type,
              hp: Math.round(type.baseHp * modifier),
              maxHp: Math.round(type.baseHp * modifier),
              atk: Math.round(type.baseAtk * modifier),
              def: Math.round(type.baseDef * modifier),
            });
          }

          return monsters;
        };

        const checkAndHandleHeroDeath = () => {
          if (hero().hp > 0) return;
          setHero({ ...hero(), isDead: true });
          addToLog({
            message: '¬°H√©roe derrotado! Fin del juego.',
            className: 'error',
          });
        };

        const healHero = () => {
          setHero({ ...hero(), hp: hero().maxHp });
          addToLog({
            message: '¬°H√©roe curado completamente!',
            className: 'success',
          });
        };

        const startBattle = () => {
          if (hero().isDead) return;

          if (hero().battlesLeft <= 0) {
            addToLog({
              message: '¬°Se acabaron tus batallas! Fin del juego.',
              className: 'error',
            });
            setHero({
              ...hero(),
              isDead: true,
            });
            checkAndHandleHeroDeath();
            return;
          }

          if (currentMonsters().length > 0) {
            addToLog({
              message: '¬°Est√°s en una batalla!',
              className: 'error',
            });
            return;
          }

          const newMonsters = generateMonsters();
          setCurrentMonsters(newMonsters);
          setDidEscape(false);

          const monsterNames = newMonsters.map(m => m.name).join(', ');
          addToLog({
            message: `Te has encontrado con: ${monsterNames}`,
            className: 'warning',
          });
        };

        const addToLog = message => {
          const logEntry = typeof message === 'string' ? { message, className: 'info' } : message;
          setBattleLog([...battleLog(), logEntry]);
        };

        const attack = () => {
          if (hero().isDead || currentMonsters().length === 0) return;

          const monster = currentMonsters()[0];
          const damage = Math.max(1, hero().atk - monster.def);
          monster.hp -= damage;
          addToLog({
            message: `H√©roe ataca a ${monster.name} por ${damage} de da√±o (${monster.hp}/${monster.maxHp} HP)`,
            className: 'info',
          });

          const monsterDamage = Math.max(1, monster.atk - hero().def);
          setHero({
            ...hero(),
            hp: Math.max(0, hero().hp - monsterDamage),
          });
          addToLog({
            message: `${monster.name} ataca al h√©roe por ${monsterDamage} de da√±o`,
            className: 'warning',
          });

          if (monster.hp <= 0) {
            const expGained = monster.maxHp * (currentDungeon() + 1);
            setHero({
              ...hero(),
              exp: hero().exp + expGained,
            });
            addToLog({
              message: `${monster.name} derrotado! +${expGained} EXP. ${
                currentMonsters().length > 1
                  ? `Queda${currentMonsters().length - 1 === 1 ? '' : 'n'} ${currentMonsters().length - 1} monstruo${
                      currentMonsters().length - 1 === 1 ? '' : 's'
                    }`
                  : ''
              }`,
              className: 'info',
            });

            setCurrentMonsters(currentMonsters().filter(m => m !== monster));

            if (currentMonsters().length === 0) {
              endBattle();
            }
          }

          checkAndHandleHeroDeath();
        };

        const escape = () => {
          if (hero().isDead || currentMonsters().length === 0) return;

          const baseEscapeChance = 0.9; // 90% base
          const heroLevelBonus = hero().level * 0.1; // +10% por nivel
          const dungeonPenalty = currentDungeon() * 0.1; // -10% por nivel de mazmorra
          const monsterCountPenalty = currentMonsters().length * 0.1; // -10% por monstruo

          const escapeChance = Math.max(0.1, Math.min(0.9, baseEscapeChance + heroLevelBonus - dungeonPenalty - monsterCountPenalty));

          if (Math.random() < escapeChance) {
            addToLog({
              message: `¬°Escape exitoso! (Probabilidad: ${Math.round(escapeChance * 100)}%)`,
              className: 'success',
            });
            setCurrentMonsters([]);
            setDidEscape(true);
            endBattle();
          } else {
            addToLog({
              message: `¬°Escape fallido! (Probabilidad: ${Math.round(escapeChance * 100)}%)`,
              className: 'error',
            });
            const monster = currentMonsters()[0];
            const damage = Math.max(1, monster.atk - hero().def);
            setHero({
              ...hero(),
              hp: Math.max(0, hero().hp - damage),
            });
            addToLog({
              message: `${monster.name} ataca al h√©roe por ${damage} de da√±o`,
              className: 'error',
            });

            checkAndHandleHeroDeath();
          }
        };

        const endBattle = () => {
          if (!didEscape()) {
            if (!canAdvance()) {
              addToLog({
                message: 'Victoria. Puedes avanzar a la siguiente mazmorra!',
                className: 'success',
              });
              setCanAdvance(true);
            } else {
              addToLog({
                message: 'Victoria. Batalla terminada.',
                className: 'success',
              });
            }
          }
          if (hero().exp >= hero().expToNext) {
            setShowLevelUp(true);
            addToLog({
              message: `¬°Subiste al nivel ${hero().level + 1}!`,
              className: 'success',
            });
          }
          setHero({
            ...hero(),
            battlesLeft: hero().battlesLeft - 1,
          });
        };

        const advanceDungeon = () => {
          if (!canAdvance()) {
            addToLog({
              message: `¬°No puedes avanzar a la siguiente mazmorra a√∫n! Debes ganar al menos 1 batalla`,
              className: 'error',
            });
            return;
          } else if (currentDungeon() === 8) {
            addToLog({
              message: `¬°Has superado todas las mazmorras! Ganaste el juego, felicidades.`,
              className: 'success',
            });
            setHero({
              ...hero(),
              isVictory: true,
            });
          } else {
            healHero();
            setCurrentDungeon(currentDungeon() + 1);
            setCanAdvance(false);
            addToLog({
              message: `¬°Avanzaste a la Mazmorra ${romanNumerals[currentDungeon()]}!`,
              className: 'success',
            });
          }
        };

        const levelUp = stat => {
          const newHero = {
            ...hero(),
            level: hero().level + 1,
            exp: hero().exp - hero().expToNext,
            expToNext: Math.floor(hero().expToNext * 1.5),
          };

          switch (stat) {
            case 'hp':
              newHero.maxHp += 35;
              newHero.hp = newHero.maxHp;
              break;
            case 'atk':
              newHero.atk += 5;
              break;
            case 'def':
              newHero.def += 5;
              break;
          }

          setHero(newHero);
          setShowLevelUp(false);
          healHero();
        };

        const resetGame = () => {
          setHero({
            level: 1,
            hp: 100,
            maxHp: 100,
            atk: 10,
            def: 5,
            exp: 0,
            expToNext: 100,
            battlesLeft: 100,
            isDead: false,
          });
          setCurrentDungeon(0);
          setCurrentMonsters([]);
          setBattleLog([]);
          setShowLevelUp(false);
          setDidEscape(false);
          setCanAdvance(false);
          addToLog({
            message: 'Nueva partida',
            className: 'info',
          });
        };

        const isEndGame = () => hero().isDead || hero().isVictory;

        return h(
          Fragment,
          null,
          h(
            'div',
            { className: 'container' },
            h('h1', null, 'Mini RPG'),
            h('h2', { className: () => (hero().isDead ? 'game-over' : hero().isVictory ? 'game-victory' : 'game-status') }, () =>
              hero().isDead
                ? '¬°H√©roe derrotado! Fin del juego.'
                : hero().isVictory
                ? 'Ganaste el juego, felicidades.'
                : `Mazmorra ${romanNumerals[currentDungeon()]}`
            ),
            h('div', { className: 'stats' }, [
              h('div', null, () => `Nivel: ${hero().level}`),
              h('div', { className: () => (hero().hp / hero().maxHp <= 0.35 ? 'low-hp' : '') }, () => `HP: ${hero().hp}/${hero().maxHp}`),
              h('div', null, () => `ATK: ${hero().atk}`),
              h('div', null, () => `DEF: ${hero().def}`),
              h(
                'div',
                { className: () => (hero().exp >= hero().expToNext ? 'ready-to-level' : '') },
                () => `EXP: ${hero().exp}/${hero().expToNext}`
              ),
              h('div', null, () => `Batallas: ${hero().battlesLeft}`),
            ]),
            h(
              'div',
              { className: 'battle-log' },
              Array.from({ length: 50 }, (_, i) =>
                h(
                  'div',
                  { key: i, className: () => `message ${battleLog()[battleLog().length - i - 1]?.className}` },
                  () => battleLog()[battleLog().length - i - 1]?.message
                )
              )
            ),
            h('div', null, [
              h('button', { className: () => (isEndGame() ? '' : 'hidden'), onclick: resetGame }, 'Empezar de nuevo'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: startBattle }, 'Explorar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: attack }, 'Atacar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: escape }, 'Escapar'),
              h('button', { className: () => (isEndGame() ? 'hidden' : ''), onclick: advanceDungeon }, 'Avanzar Mazmorra'),
            ]),
            h('div', { id: 'level-up', className: () => (!isEndGame() && showLevelUp() ? 'level-up visible' : 'level-up') }, [
              h('h2', null, '¬°Subiste de nivel!'),
              h('button', { onclick: () => levelUp('hp') }, 'Aumentar HP'),
              h('button', { onclick: () => levelUp('atk') }, 'Aumentar ATK'),
              h('button', { onclick: () => levelUp('def') }, 'Aumentar DEF'),
            ])
          ),
          h('div', { className: 'container info-section' }, [
            h('h2', null, 'Informaci√≥n y Preguntas Frecuentes'),
            h('div', { className: 'info-content' }, [
              h('h3', null, 'Objetivo'),
              h('p', null, 'Supera las 10 mazmorras antes de agotar tus 100 batallas disponibles.'),
              h('h3', null, '¬øC√≥mo jugar?'),
              h('p', null, '1. Inicia una batalla usando el bot√≥n "Iniciar Batalla".'),
              h('p', null, '2. Cada batalla tiene varios monstruos. M√°talos todos para ganar batallas.'),
              h('p', null, '3. Gana experiencia y sube de nivel.'),
              h('p', null, '4. Avanza a mazmorras m√°s dif√≠ciles.'),
              h('h3', null, 'Mec√°nicas importantes'),
              h('p', null, '- El h√©roe se cura s√≥lo al subir de nivel y al avanzar de mazmorra.'),
              h('p', null, '- La probabilidad de escape depende de tu nivel, la mazmorra y el n√∫mero de monstruos vivos.'),
              h('p', null, '- El h√©roe s√≥lo sube de nivel al terminar batallas, ya sea escapando o ganando.'),
              h('h3', null, 'Consejos'),
              h('p', null, '- No subestimes una retirada t√°ctica para seguir con vida.'),
              h(
                'p',
                null,
                '- Puedes guardar la subida de nivel para cuando tengas vida baja para curarte. S√≥lo sube 1 nivel a la vez, as√≠ que no guardes mucha experiencia.'
              ),
            ]),
          ])
        );
      }

      const root = document.body;
      root.appendChild(Game());
    </script>
  </body>
</html>
